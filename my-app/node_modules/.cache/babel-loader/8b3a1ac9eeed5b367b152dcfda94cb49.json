{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\n\nconst _ = require(\"lodash\");\n\nfunction getDataMapKey(path, location) {\n  return `${location}:${path}`;\n}\n\nclass Context {\n  constructor(fields, locations, stack, optional, message) {\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n\n  get errors() {\n    return this._errors;\n  }\n\n  getData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      requiredOnly: false\n    };\n    // Have to store this.optional in a const otherwise TS thinks the value could have changed\n    // when the functions below run\n    const {\n      optional\n    } = this;\n    const checks = options.requiredOnly && optional ? [value => value !== undefined, value => optional.nullable ? value != null : true, value => optional.checkFalsy ? value : true] : [];\n    return _([...this.dataMap.values()]).groupBy('originalPath').flatMap((instances, group) => {\n      const locations = _.uniqBy(instances, 'location'); // #331 - When multiple locations are involved, all of them must pass the validation.\n      // If none of the locations contain the field, we at least include one for error reporting.\n      // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n      // paths, so we may want to skip this filtering.\n\n\n      if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n        const withValue = instances.filter(instance => instance.value !== undefined);\n        return withValue.length ? withValue : [instances[0]];\n      }\n\n      return instances;\n    }).filter(instance => checks.every(check => check(instance.value))).valueOf();\n  }\n\n  addFieldInstances(instances) {\n    instances.forEach(instance => {\n      this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n    });\n  }\n\n  setData(path, value, location) {\n    const instance = this.dataMap.get(getDataMapKey(path, location));\n\n    if (!instance) {\n      throw new Error('Attempt to write data that did not pre-exist in context');\n    }\n\n    instance.value = value;\n  }\n\n  addError(message, valueOrNestedErrors, meta) {\n    const msg = message || this.message || 'Invalid value';\n\n    if (meta) {\n      this._errors.push({\n        value: valueOrNestedErrors,\n        msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n        param: meta.path,\n        location: meta.location\n      });\n    } else {\n      this._errors.push({\n        msg,\n        param: '_error',\n        nestedErrors: valueOrNestedErrors\n      });\n    }\n  }\n\n}\n\nexports.Context = Context;","map":{"version":3,"names":["Object","defineProperty","exports","value","Context","_","require","getDataMapKey","path","location","constructor","fields","locations","stack","optional","message","_errors","dataMap","Map","errors","getData","options","requiredOnly","checks","undefined","nullable","checkFalsy","values","groupBy","flatMap","instances","group","uniqBy","length","includes","withValue","filter","instance","every","check","valueOf","addFieldInstances","forEach","set","assign","setData","get","Error","addError","valueOrNestedErrors","meta","msg","push","param","nestedErrors"],"sources":["E:/library/library_management/node_modules/express-validator/src/context.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Context = void 0;\r\nconst _ = require(\"lodash\");\r\nfunction getDataMapKey(path, location) {\r\n    return `${location}:${path}`;\r\n}\r\nclass Context {\r\n    constructor(fields, locations, stack, optional, message) {\r\n        this.fields = fields;\r\n        this.locations = locations;\r\n        this.stack = stack;\r\n        this.optional = optional;\r\n        this.message = message;\r\n        this._errors = [];\r\n        this.dataMap = new Map();\r\n    }\r\n    get errors() {\r\n        return this._errors;\r\n    }\r\n    getData(options = { requiredOnly: false }) {\r\n        // Have to store this.optional in a const otherwise TS thinks the value could have changed\r\n        // when the functions below run\r\n        const { optional } = this;\r\n        const checks = options.requiredOnly && optional\r\n            ? [\r\n                (value) => value !== undefined,\r\n                (value) => (optional.nullable ? value != null : true),\r\n                (value) => (optional.checkFalsy ? value : true),\r\n            ]\r\n            : [];\r\n        return _([...this.dataMap.values()])\r\n            .groupBy('originalPath')\r\n            .flatMap((instances, group) => {\r\n            const locations = _.uniqBy(instances, 'location');\r\n            // #331 - When multiple locations are involved, all of them must pass the validation.\r\n            // If none of the locations contain the field, we at least include one for error reporting.\r\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\r\n            // paths, so we may want to skip this filtering.\r\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\r\n                const withValue = instances.filter(instance => instance.value !== undefined);\r\n                return withValue.length ? withValue : [instances[0]];\r\n            }\r\n            return instances;\r\n        })\r\n            .filter(instance => checks.every(check => check(instance.value)))\r\n            .valueOf();\r\n    }\r\n    addFieldInstances(instances) {\r\n        instances.forEach(instance => {\r\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\r\n        });\r\n    }\r\n    setData(path, value, location) {\r\n        const instance = this.dataMap.get(getDataMapKey(path, location));\r\n        if (!instance) {\r\n            throw new Error('Attempt to write data that did not pre-exist in context');\r\n        }\r\n        instance.value = value;\r\n    }\r\n    addError(message, valueOrNestedErrors, meta) {\r\n        const msg = message || this.message || 'Invalid value';\r\n        if (meta) {\r\n            this._errors.push({\r\n                value: valueOrNestedErrors,\r\n                msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\r\n                param: meta.path,\r\n                location: meta.location,\r\n            });\r\n        }\r\n        else {\r\n            this._errors.push({\r\n                msg,\r\n                param: '_error',\r\n                nestedErrors: valueOrNestedErrors,\r\n            });\r\n        }\r\n    }\r\n}\r\nexports.Context = Context;\r\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AACA,MAAMC,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,QAA7B,EAAuC;EACnC,OAAQ,GAAEA,QAAS,IAAGD,IAAK,EAA3B;AACH;;AACD,MAAMJ,OAAN,CAAc;EACVM,WAAW,CAACC,MAAD,EAASC,SAAT,EAAoBC,KAApB,EAA2BC,QAA3B,EAAqCC,OAArC,EAA8C;IACrD,KAAKJ,MAAL,GAAcA,MAAd;IACA,KAAKC,SAAL,GAAiBA,SAAjB;IACA,KAAKC,KAAL,GAAaA,KAAb;IACA,KAAKC,QAAL,GAAgBA,QAAhB;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKC,OAAL,GAAe,EAAf;IACA,KAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;EACH;;EACS,IAANC,MAAM,GAAG;IACT,OAAO,KAAKH,OAAZ;EACH;;EACDI,OAAO,GAAoC;IAAA,IAAnCC,OAAmC,uEAAzB;MAAEC,YAAY,EAAE;IAAhB,CAAyB;IACvC;IACA;IACA,MAAM;MAAER;IAAF,IAAe,IAArB;IACA,MAAMS,MAAM,GAAGF,OAAO,CAACC,YAAR,IAAwBR,QAAxB,GACT,CACGX,KAAD,IAAWA,KAAK,KAAKqB,SADvB,EAEGrB,KAAD,IAAYW,QAAQ,CAACW,QAAT,GAAoBtB,KAAK,IAAI,IAA7B,GAAoC,IAFlD,EAGGA,KAAD,IAAYW,QAAQ,CAACY,UAAT,GAAsBvB,KAAtB,GAA8B,IAH5C,CADS,GAMT,EANN;IAOA,OAAOE,CAAC,CAAC,CAAC,GAAG,KAAKY,OAAL,CAAaU,MAAb,EAAJ,CAAD,CAAD,CACFC,OADE,CACM,cADN,EAEFC,OAFE,CAEM,CAACC,SAAD,EAAYC,KAAZ,KAAsB;MAC/B,MAAMnB,SAAS,GAAGP,CAAC,CAAC2B,MAAF,CAASF,SAAT,EAAoB,UAApB,CAAlB,CAD+B,CAE/B;MACA;MACA;MACA;;;MACA,IAAIA,SAAS,CAACG,MAAV,GAAmB,CAAnB,IAAwBrB,SAAS,CAACqB,MAAV,GAAmB,CAA3C,IAAgD,CAACF,KAAK,CAACG,QAAN,CAAe,GAAf,CAArD,EAA0E;QACtE,MAAMC,SAAS,GAAGL,SAAS,CAACM,MAAV,CAAiBC,QAAQ,IAAIA,QAAQ,CAAClC,KAAT,KAAmBqB,SAAhD,CAAlB;QACA,OAAOW,SAAS,CAACF,MAAV,GAAmBE,SAAnB,GAA+B,CAACL,SAAS,CAAC,CAAD,CAAV,CAAtC;MACH;;MACD,OAAOA,SAAP;IACH,CAbM,EAcFM,MAdE,CAcKC,QAAQ,IAAId,MAAM,CAACe,KAAP,CAAaC,KAAK,IAAIA,KAAK,CAACF,QAAQ,CAAClC,KAAV,CAA3B,CAdjB,EAeFqC,OAfE,EAAP;EAgBH;;EACDC,iBAAiB,CAACX,SAAD,EAAY;IACzBA,SAAS,CAACY,OAAV,CAAkBL,QAAQ,IAAI;MAC1B,KAAKpB,OAAL,CAAa0B,GAAb,CAAiBpC,aAAa,CAAC8B,QAAQ,CAAC7B,IAAV,EAAgB6B,QAAQ,CAAC5B,QAAzB,CAA9B,EAAkET,MAAM,CAAC4C,MAAP,CAAc,EAAd,EAAkBP,QAAlB,CAAlE;IACH,CAFD;EAGH;;EACDQ,OAAO,CAACrC,IAAD,EAAOL,KAAP,EAAcM,QAAd,EAAwB;IAC3B,MAAM4B,QAAQ,GAAG,KAAKpB,OAAL,CAAa6B,GAAb,CAAiBvC,aAAa,CAACC,IAAD,EAAOC,QAAP,CAA9B,CAAjB;;IACA,IAAI,CAAC4B,QAAL,EAAe;MACX,MAAM,IAAIU,KAAJ,CAAU,yDAAV,CAAN;IACH;;IACDV,QAAQ,CAAClC,KAAT,GAAiBA,KAAjB;EACH;;EACD6C,QAAQ,CAACjC,OAAD,EAAUkC,mBAAV,EAA+BC,IAA/B,EAAqC;IACzC,MAAMC,GAAG,GAAGpC,OAAO,IAAI,KAAKA,OAAhB,IAA2B,eAAvC;;IACA,IAAImC,IAAJ,EAAU;MACN,KAAKlC,OAAL,CAAaoC,IAAb,CAAkB;QACdjD,KAAK,EAAE8C,mBADO;QAEdE,GAAG,EAAE,OAAOA,GAAP,KAAe,UAAf,GAA4BA,GAAG,CAACF,mBAAD,EAAsBC,IAAtB,CAA/B,GAA6DC,GAFpD;QAGdE,KAAK,EAAEH,IAAI,CAAC1C,IAHE;QAIdC,QAAQ,EAAEyC,IAAI,CAACzC;MAJD,CAAlB;IAMH,CAPD,MAQK;MACD,KAAKO,OAAL,CAAaoC,IAAb,CAAkB;QACdD,GADc;QAEdE,KAAK,EAAE,QAFO;QAGdC,YAAY,EAAEL;MAHA,CAAlB;IAKH;EACJ;;AAtES;;AAwEd/C,OAAO,CAACE,OAAR,GAAkBA,OAAlB"},"metadata":{},"sourceType":"script"}